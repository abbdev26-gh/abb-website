import{d as N}from"./DuAV58dt.js";import{p as w,a0 as q,a1 as A,a2 as L,a3 as T,a4 as V,H as W,A as j,a5 as S,o as z,a6 as G,c as x,r as U,f as M,a7 as J,a8 as Q,a9 as X,y as B,aa as Y,G as Z}from"./D28GIEcV.js";function ra(...a){const e=typeof a[a.length-1]=="string"?a.pop():void 0;$(a[0],a[1])&&a.unshift(e);let[u,s,r={}]=a,D=!1;const n=w(()=>q(u));if(typeof n.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof s!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const t=A();r.server??=!0,r.default??=k,r.getCachedData??=H,r.lazy??=!1,r.immediate??=!0,r.deep??=L.deep,r.dedupe??="cancel",r._functionName,t._asyncData[n.value];function h(){const l={cause:"initial",dedupe:r.dedupe};return t._asyncData[n.value]?._init||(l.cachedData=r.getCachedData(n.value,t,{cause:"initial"}),t._asyncData[n.value]=R(t,n.value,s,r,l.cachedData)),()=>t._asyncData[n.value].execute(l)}const m=h(),o=t._asyncData[n.value];o._deps++;const v=r.server!==!1&&t.payload.serverRendered;{let l=function(c){const i=t._asyncData[c];i?._deps&&(i._deps--,i._deps===0&&i?._off())};const d=T();if(d&&v&&r.immediate&&!d.sp&&(d.sp=[]),d&&!d._nuxtOnBeforeMountCbs){d._nuxtOnBeforeMountCbs=[];const c=d._nuxtOnBeforeMountCbs;V(()=>{c.forEach(i=>{i()}),c.splice(0,c.length)}),W(()=>c.splice(0,c.length))}const C=d&&(d._nuxtClientOnly||j(G,!1));v&&t.isHydrating&&(o.error.value||o.data.value!==void 0)?o.status.value=o.error.value?"error":"success":d&&(!C&&t.payload.serverRendered&&t.isHydrating||r.lazy)&&r.immediate?d._nuxtOnBeforeMountCbs.push(m):r.immediate&&o.status.value!=="success"&&m();const f=x(),_=S(n,(c,i)=>{if((c||i)&&c!==i){D=!0;const O=t._asyncData[i]?.data.value!==void 0,I=t._asyncDataPromises[i]!==void 0,P={cause:"initial",dedupe:r.dedupe};if(!t._asyncData[c]?._init){let E;i&&O?E=t._asyncData[i].data.value:(E=r.getCachedData(c,t,{cause:"initial"}),P.cachedData=E),t._asyncData[c]=R(t,c,s,r,E)}t._asyncData[c]._deps++,i&&l(i),(r.immediate||O||I)&&t._asyncData[c].execute(P),Y(()=>{D=!1})}},{flush:"sync"}),y=r.watch?S(r.watch,()=>{D||o._execute({cause:"watch",dedupe:r.dedupe})}):()=>{};f&&z(()=>{_(),y(),l(n.value)})}const b={data:p(()=>t._asyncData[n.value]?.data),pending:p(()=>t._asyncData[n.value]?.pending),status:p(()=>t._asyncData[n.value]?.status),error:p(()=>t._asyncData[n.value]?.error),refresh:(...l)=>t._asyncData[n.value]?._init?t._asyncData[n.value].execute(...l):h()(),execute:(...l)=>b.refresh(...l),clear:()=>{const l=t._asyncData[n.value];if(l?._abortController)try{l._abortController.abort(new DOMException("AsyncData aborted by user.","AbortError"))}finally{l._abortController=void 0}F(t,n.value)}},g=Promise.resolve(t._asyncDataPromises[n.value]).then(()=>b);return Object.assign(g,b),g}function p(a){return w({get(){return a()?.value},set(e){const u=a();u&&(u.value=e)}})}function $(a,e){return!(typeof a=="string"||typeof a=="object"&&a!==null||typeof a=="function"&&typeof e=="function")}function F(a,e){e in a.payload.data&&(a.payload.data[e]=void 0),e in a.payload._errors&&(a.payload._errors[e]=void 0),a._asyncData[e]&&(a._asyncData[e].data.value=B(a._asyncData[e]._default()),a._asyncData[e].error.value=void 0,a._asyncData[e].status.value="idle"),e in a._asyncDataPromises&&(a._asyncDataPromises[e]=void 0)}function K(a,e){const u={};for(const s of e)u[s]=a[s];return u}function R(a,e,u,s,r){a.payload._errors[e]??=void 0;const D=s.getCachedData!==H,n=u,t=s.deep?U:M,h=r!==void 0,m=a.hook("app:data:refresh",async v=>{(!v||v.includes(e))&&await o.execute({cause:"refresh:hook"})}),o={data:t(h?r:s.default()),pending:w(()=>o.status.value==="pending"),error:J(a.payload._errors,e),status:M("idle"),execute:(...v)=>{const[b,g=void 0]=v,l=b&&g===void 0&&typeof b=="object"?b:{};if(a._asyncDataPromises[e]&&(l.dedupe??s.dedupe)==="defer")return a._asyncDataPromises[e];{const f="cachedData"in l?l.cachedData:s.getCachedData(e,a,{cause:l.cause??"refresh:manual"});if(f!==void 0)return a.payload.data[e]=o.data.value=f,o.error.value=void 0,o.status.value="success",Promise.resolve(f)}o._abortController&&o._abortController.abort(new DOMException("AsyncData request cancelled by deduplication","AbortError")),o._abortController=new AbortController,o.status.value="pending";const d=new AbortController,C=new Promise((f,_)=>{try{const y=l.timeout??s.timeout,c=aa([o._abortController?.signal,l?.signal],d.signal,y);if(c.aborted){const i=c.reason;_(i instanceof Error?i:new DOMException(String(i??"Aborted"),"AbortError"));return}return c.addEventListener("abort",()=>{const i=c.reason;_(i instanceof Error?i:new DOMException(String(i??"Aborted"),"AbortError"))},{once:!0,signal:d.signal}),Promise.resolve(n(a,{signal:c})).then(f,_)}catch(y){_(y)}}).then(async f=>{let _=f;s.transform&&(_=await s.transform(f)),s.pick&&(_=K(_,s.pick)),a.payload.data[e]=_,o.data.value=_,o.error.value=void 0,o.status.value="success"}).catch(f=>{if(!(a._asyncDataPromises[e]&&a._asyncDataPromises[e]!==C)&&!o._abortController?.signal.aborted){if(typeof DOMException<"u"&&f instanceof DOMException&&f.name==="AbortError"){o.status.value="idle";return}o.error.value=X(f),o.data.value=B(s.default()),o.status.value="error"}}).finally(()=>{d.abort(),delete a._asyncDataPromises[e]});return a._asyncDataPromises[e]=C,a._asyncDataPromises[e]},_execute:N((...v)=>o.execute(...v),0,{leading:!0}),_default:s.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{m(),a._asyncData[e]?._init&&(a._asyncData[e]._init=!1),D||Q(()=>{a._asyncData[e]?._init||(F(a,e),o.execute=()=>Promise.resolve())})}};return o}const k=()=>{},H=(a,e,u)=>{if(e.isHydrating)return e.payload.data[a];if(u.cause!=="refresh:manual"&&u.cause!=="refresh:hook")return e.static.data[a]};function aa(a,e,u){const s=a.filter(n=>!!n);if(typeof u=="number"&&u>=0){const n=AbortSignal.timeout?.(u);n&&s.push(n)}if(AbortSignal.any)return AbortSignal.any(s);const r=new AbortController;for(const n of s)if(n.aborted){const t=n.reason??new DOMException("Aborted","AbortError");try{r.abort(t)}catch{r.abort()}return r.signal}const D=()=>{const t=s.find(h=>h.aborted)?.reason??new DOMException("Aborted","AbortError");try{r.abort(t)}catch{r.abort()}};for(const n of s)n.addEventListener?.("abort",D,{once:!0,signal:e});return r.signal}function na(){const a=(e,u)=>{e.forEach(s=>{s.isIntersecting&&(s.target.classList.add("animate-in"),u.unobserve(s.target))})};Z(()=>{const e=new IntersectionObserver(a,{threshold:.1,rootMargin:"50px"});document.querySelectorAll(".animate-on-scroll").forEach(s=>e.observe(s))})}export{na as a,ra as u};
